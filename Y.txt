Yの訳

どうやってYが動き誰が思いついたのか、考えたことがありますか?
このノートで、それがどのように動くかだけでなく、どのように考案されたのかについて説明しようと思う。schemeの記法を用いるのは、引数として渡された関数が適用されたときに、より理解しやすいためである。

Yのポイントは、自己参照プログラムを書くメカニズムを
特別に用意された手段を用いることなしに、提供するためのものである。
schemeにおいては、そのようなプログラムを書くためのメカニズムがいくつか存在し、globalなdefineやletrecがそこに含まれる。階乗関数を書く一つの方法をここに示す。

(define fact
  (lambda (n)
    (if (< n 2) 1 (* n (fact (- n 1))))))b

これは動く

letrecを使うプログラムは以下のとおり。
(letrec 
    ((f (lambda (n)
	  (if (< n 2) 
	      1
	      (* n (f (- n 1)))))))
  (f 10)) ;; => 3628800
;;
このプログラムは 10!を計算する。 lambda 式のなかのfへの参照は
letrecによって確立されたfへの束縛である。

letrecは、letとset!を使って実装する異も出来る。

(letrec ((f (lambda ....))) ....)
は次の式と等価である。
(let ((f <undefined>))
  (set! f (lambda (...) ....)) ...)


lambda 式本体のなかのfへのすべての参照は、lambda式の値（lambda式そのもの？）への参照である


Y
再帰的または自己参照的な関数を表すように見える関数を引数に？とる関数であり、
そんなかんじの関数を生み出す、とある別の関数を返す。
Yが 10!を計算するためにどのように用いられるかを下に示す。

(let ((f (y (lambda (h)
              (lambda (n)
                (if (< n 2) 1 (* n (h (- n 1)))))))))
  (f 10))

Yに一つの引数として渡されている関数は、引数として関数をとり、我々が定義したいような階乗関数のように見える関数を返している。すなわちYに引き渡される関数は、 (lambda (h) ...)という形をしており、この関数のBodyは、

階乗関数のために再帰的な呼び出しを期待するところを除き、その代わりに h が呼び出されている。 階乗関数のそのもののように見える

Y は
hの値として提供される最適な値を用意する。


人々はYを
汎関数のための適用可能な不動点オペレータと呼ぶ。
This works because there is a global variable, fact, that has its value set to the value of the lambda
expression. 

これは動作する。なぜなら、大域変数である fact があり、 それは、ラムダ式を値としてセットされた値を持つから。


When the variable fact in the body of the function is evaluated to determine which
function to invoke, the value is found in the global variable. In some sense using a global variable as a
function name is unpleasant because it relies on a global and hence a vulnerable resource -- the global
variable space.


関数のbodyのなかにある 変数 fact は、決定するためにどちらの関数が呼ばれるべきかを評価される時に、factの値は、大域変数の中に見つかる。
いくつかの意味において、(in some sence)関数名として、大域変数が使われることは、unpleasantであるなぜなら、そのことは、globalで、それゆえに傷つきやすいリソース（大域変数領域）に依存するからである。


fは、プラトン世界において、"真の"数学的階乗関数であると仮定しよう。
Fを次のような関数として記述する。

F = (lambda (h) (lambdsa (n) (if (< n 2) 1 (* n (h (- n 1))))))



((F f) n) = (f n)であるとき、 すなわち f を Fの不動点という。 F は（いくつかの意味において f を f自身にmapする（対応させる）。
Yは、次の特徴を満たす。

((F (Y F))) x) = ((Y F) x).

これはYの非常に重要な特徴である。
The other important property is that the least defined fixed point for functionals is unique,
他の重要な特徴は、最も簡素に定義された関数の不動点は唯一であることであり、（意味が取れん・・・）
それゆえ、(Y F) と f はいくつかの意味において同じなのである。

＃  固有ベクトルがどーのこーのという話と対応してるのか?

適用可能なYは、古典的なYと同じではない。Yはコンビネータである。
いくつかの文章の中では、我々がYと呼ぶものはZと呼ばれている。

Yを導出するために、再帰関数である階乗の例で始めてみよう。導湯角過程において、私は、三つのテクニックを使う。
最初のは、付加的な引数をスキームのあらゆる自己参照を使用することを避けるために パスすること。
二つ目は、複数のパラメータを一つのパラメータにまとめること。自己参照パラメータの操作と
通常のパラメータへの操作を区別するため。
三つ目は、抽象化を通して、関数を導出すること。


すべてのコード例は 
変数 nと変数mが整数への参照 
変数 x が分からないか、区別されていない引数への参照
そして、f,g,hまたは、rが関数への参照

階乗関数の基本形式は、以下のとおり、

(lambda (h) (if (< n 2) 1 (* n (h (- n 1)))))

変数 h は、再帰的呼び出しが生成されたときに呼び出されると期待する関数への参照であるべきで、
階乗関数そのものでもある。
hが直裁に正しい関数に対して、参照させる方法を持っていないので、引数を追加しよう。

(lambda (h n) (if (< n 2) 1 (n * (h h (- n 1)))))

hに対する再帰的呼び出しにおいて、最初の引数は、hであるべきです。なぜなら、我々は、

hへの再帰的呼び出しでは、また、再帰的な状況で
関数の後の実施に使用する正しい関数を伝えたいと思うので、最初の引数はhになるでしょう。

(let ((g (lambda (h n)
       (if (< n 2) 1 (* n (h h (- n 1)))))))
  (g g 10))

g の bodyを評価することを通して、hの値は、let によって確立した g の値と同じである。
すなわち、gを実行することを通して、hは、実行する関数を参照する。
関数呼び出し (h h (- n 1) が発生するとき、同じ値がhに引き渡される hは自分自身を自分自身に引き渡す。

我々がほしいものは、 しかしながら、その関数への自己参照のmanagementを 他の引数のmanagementから引き離すものである。
この場合においては、我々は、hのmanagementをnのmanagementと区別することである。
これを行なう普通の方法は、カリー化と呼ばれるテクニックを用いる。この例でカリー化をおこなうまえに、別のカリー化の例を見てみよう。これは、やはり10!をけいさんするが、もう少しだけ賢いやり方である。

(letrec ((f (lambda (n m)
           (if (< n 2) m (f (- n 1) (* n m))))))
  (f 10 1))

これは、結果計算用のアキュムレータ m をつかうトリックである。この関数は、schemeにおける反復をあらわすが、そのことは重要でない。 
fの定義をカリー化してみよう


(letrec ((f (lambda (n)
          (lambda (m)
        (if (< n 2) m ((f (- n 1)) (* m n)))))))
  ((f 10) 1))

カリー化の考え方は、全ての関数は、一つの引数をとり、複数の引数をとくことは、関数をネスト（入れ子に）して適用するというものである。
最初の関数適用は、二つ目の引数をとる関数を返し、計算を完了する。 上記のコードにおいては、再帰呼び出し
((f (- n 1)) (* m n)) は二つののステップをもつ。 適切な適用される関数が計算される。そしてその後に右の引数のために適用される。

このカリー化の考えを階乗関数に使ってみよう。

(let ((g (lambda (h)
       (lambda (n)
         (if (< n 2) 1 (* n ((h h) (- n 1))))))))
  ((g g) 10))
      
このコード変においては、再帰呼び出しは二つのStepを持ち、最初ののは、適切な適用すべき関数を計算することである
しかし、適せるな関数は、関数をそれ自身に適用することで得られる。

関数を自分自身に適用することは、自己参照の basic funtionalityをどのようにgetするかということである。




プログラムの最後行の、自己適用 (g g)は gそれ自身を引数にして呼び出している。これは、変数Hが外側のgで束縛された変数hを内側に含むクロージャを返却する。
このクロージャは、数値を引数に取り、基本的は、階乗計算を行なう。もし、その計算が再帰呼び出しを必要とするならば、引数として、クローズドオーバーされたhをクローズドオーバーされたh呼び出すが、しかし、そこにあるすべてのhは、letによって定義された関数 gに束縛されている。

我々はこのトリックを要約することが出来る。
letrecを使って次のようなコードスケルトンを持つ自己参照的な関数があると仮定しよう。

(letrec ((f (lambda (x) ... f ... ))) .... f .... )

そのときletを使って次のように変形させることが出来る。
(let ((f (lambda (r) (lambda (x) ... (r r) ...))) ... (f f) ...))

r は、新しく導入した識別子

集中してこれからさらに hの扱いと nの扱いをどうやって分離するかを考えよう。 
思い出してみるに、階乗プログラムは、以下のようなものだった。

(let ((g (lambda (h)
       (lambda (n)
         (if (< n 2) 
         1 
         (* n ((h h) (- n 1))))))))
  ((g g) 10))

われわれの攻撃プランは、if式の中にある (h h) とnを抽象化することである。
これは、二つのことを完遂する
関数の結果は、周りの束縛された環境から独立する。
数値の引数の扱いと制御の扱いを分離させることが出来る。
次に抽象化の結果を載せる。

(let ((g (lambda (h)
       (lambda (n)
         (let ((f (lambda (q n)
            (if (< n 2) 1 (* n (q (- n 1)))))))
           (f (h h) n))))))
  ((g g) 10))



我々は f の定義のカリー化が出来る。 そしてそれは次のようになる。


(let ((g (lambda (h)
       (lambda (n)
         (let ((f (lambda (q)
            (lambda (n)
              (if (< n 2) 1 (* n (q (- n 1))))))))
           ((f (h h)) n))))))
  ((g g) 10))

fを一番外に出す。

(let ((f (lambda (q) (lambda (n) (if (< n 2) 1 (* n (q (- n 1))))))))
  (let ((g (lambda (h)
         (lambda (n)
           ((f (h h)) n)))))
    ((g g) 10)))

二行目以降を関数にして テキトーな変数 Yに束縛して出来上がり。

(define Y
(lambda (f)
  (let ((g (lambda (h)
         (lambda (n)
           ((f (h h)) n)))))
    (g g)))
